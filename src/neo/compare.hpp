#pragma once

#include "neo/attrib.hpp"
#include "neo/declval.hpp"
#include <neo/concepts.hpp>

#include <compare>

namespace neo {

struct synth_three_way_fn {
    template <typename T, three_way_comparable_with<T> U>
    NEO_ALWAYS_INLINE constexpr std::compare_three_way_result_t<T, U>
    operator()(const T& t, const U& u) const noexcept {
        return t <=> u;
    }

    template <typename T, typename U>
        requires(not three_way_comparable_with<T, U>)
    constexpr std::weak_ordering operator()(const T& t, const T& u) noexcept
        requires requires {
            { t < u } -> simple_boolean;
            { u < t } -> simple_boolean;
        }
    {
        if (t < u) {
            return std::weak_ordering::less;
        } else if (u < t) {
            return std::weak_ordering::greater;
        }
        return std::weak_ordering::equivalent;
    }
};

/**
 * @brief A binary-invocable object that performs an effective three-way comparison
 * between two objects of arbitrary type. It is only requires that the objects
 * be less-than comparable.
 *
 * If a full `operator<=>` is available, it will be used, otherwise a `std::weak_ordering`
 * will be generated by two calls to `operator<`.
 *
 * Based on the exposition-only `synth-three-way` used throughout the standard library.
 */
inline constexpr synth_three_way_fn synth_three_way;

template <typename T, typename U>
using synth_three_way_result_t
    = decltype(synth_three_way(NEO_DECLVAL(T const&), NEO_DECLVAL(U const&)));

}  // namespace neo